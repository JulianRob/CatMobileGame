<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_tPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hsp = 0; //Horizontal Speed
vsp = 0; //Vertical Speed
gsp = 0; //Ground Speed
hspl = 20; //Horizontal Speed Limit
vspl = 20; //Vertical Speed Limit

grav = 1; //Gravity; 

grounded = false; //On the Ground

fric = 0.2; //Friction; 0.2

jumpSpeed = 30; //Speed Added When Pressing Jump Button (W)
rightSpeed = 1; //Speed Added When Holding Right Button (D)
leftSpeed = 1; //Speed Added When Holding Left Button (A)

angle = 0; //Angle of the Cat Relative to Ground.

drawLine = false; //Draws Line from Player to Ground

x1 = 0; //Distance BEtween Top LEft Line and Top Right Line
y1 = 0; //Distance from Top Right to Bottom Right.
x2 = 0; //Point of Top Left Line
y2 = 0; //Distance from Top Left to Bottom Left
diff1X = 0; //Length of the Right Line.
diff1Y = 0;  //Length of the Left Line.

fpositionx = 0; //Initial Position of Cat Before Movement
lpositionx = 0; //Final Position of Cat After Movement
positionx = 0; //Difference in Positions of Cat

kills = 0; //Number of Kills Player Gets

rightLast = false; //Right is the Last Direction Pressed
leftLast = false; //Left is the Last Direction Pressed

test = 0; //Testing Variables
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>fpositionx = x;

//BUTTONS
right = keyboard_check(ord("D"));
left = keyboard_check(ord("A"));
jump = keyboard_check(ord("W"));

////////////////////////////////////////////////////PHYSICS PROPERTIES
//GRAVITY
if(!grounded)
{
    vsp += grav;
}

//HORIZONTAL AND VERTICAL FRICTION
if (hsp &gt; 0) {hsp -= fric;}
if (hsp &lt; 0) {hsp += fric;}
if (abs(hsp) &lt; fric) {hsp = 0;}

if(grounded)
{
    if (vsp &gt; 0) {vsp -=fric;}
    if (vsp &lt; 0) {vsp += fric;}
    if (abs(vsp) &lt; fric) {vsp = 0;}
}

//SPEED LIMITS
if(hsp &gt; hspl) {hsp = hspl;}
if(hsp &lt; -hspl) {hsp = -hspl;}
if(vsp &gt; vspl) {vsp = vspl;}
if(vsp &lt; -vspl) {vsp = -vspl;}

//DRAWS LINE FROM PLAYER TO GROUND
if(grounded)
{
    //RIGHT LINE
    for(yy = 0; !position_meeting((x+cos(degtorad(angle))*10) + sin(degtorad(angle))*yy,(y-sin(degtorad(angle))*10)+cos(degtorad(angle))*yy,obj_stable_ground); yy++)
         {
             diff1X = yy; //Length of the right line.
             if(yy &gt;= 100)
             {
                 break;
             }
         }
    //LEFT LINE
    for(yy = 0; !position_meeting(x+(sin(degtorad(angle))*yy),y+(cos(degtorad(angle))*yy),obj_stable_ground); yy++)
     {
         diff1Y = yy; //Length of the left line. 
         if(yy &gt;= 100)
         {
             break;
         }
     }
    
    //Point of bottom right line. 
    x1 = (x+cos(degtorad(angle))*10) + sin(degtorad(angle))*diff1X; //Distance between top left line and top right line. 
    y1 = (y-sin(degtorad(angle))*10)+ cos(degtorad(angle))*diff1X; //Distance from top right to bottom right. 
    
    //Point of bottom left line. 
    x2 = x+(sin(degtorad(angle))*diff1Y); //Point of top left line. 
    y2 = y+(cos(degtorad(angle))*diff1Y); //Distance from top left to bottom left. 
    
    //Distance of slope
    var dist = sqrt(power(x2-x1,2)+power(y2-y1,2));
    
    //The distance of the slope is always costant. The difference in the lengths
    //of the lines will be 0 when angle is equal to the angle of the slope. 
    if(radtodeg(arctan2(diff1Y-diff1X,dist)) != 0)
    {
        angle += radtodeg(arctan2(diff1Y-diff1X,dist));
    }
    
    drawLine = true;
}
else
{
    drawLine = false;
}

////////////////////////////////////////////////////PHYSICS PROPERTIES

//BUTTON PROPERTIES
if(grounded)
{
    ////CHANGES DIRECTION OF PLAYER BASED ON ANGLE
    if(right) 
    {          
        //ADDS SPEED TO DIRECTION
         hsp += cos(degtorad(angle))*rightSpeed; 
         vsp -= sin(degtorad(angle))*rightSpeed; 
         
         if(gsp &lt;= 1)
         {
             rightLast = true;
             leftLast = false;
         }
    }
    else if(left)
    {
        
        //ADDS SPEED TO DIRECTION
        hsp += -cos(degtorad(angle))*rightSpeed; 
        vsp +=  sin(degtorad(angle))*rightSpeed; 
        
        if(gsp &lt;= 1)
        {
           rightLast = false;
           leftLast = true;
        }
    }
    
    /*
    //DECREASE SPEED ON SLOPE
    gsp = sqrt(power(hsp,2)+power(vsp,2));
    if(angle &gt; 0 &amp;&amp; angle &lt;= 180 &amp;&amp; (!left || (left &amp;&amp; right)))
    {
        if(ln(angle+100)-4.6 &gt; gsp)
        {
            gsp = 0;
            grounded = false;
            angle = 0;
        }
        else
        {
            gsp -= ln(angle+100)-4.6;   
            if(gsp &lt; 0.5)
            {
                gsp = 0;
                grounded = false;
                angle = 0;
            }
        }
    }
    
    if(angle &gt; 180 &amp;&amp; angle &lt;= 360 &amp;&amp; !right)
    {
        if(ln(abs(360-angle)+100)-4.6 &gt; gsp)
        {
            gsp = 0;
            grounded = false;
            angle = 0;
        }
        else
        {
            gsp -= ln(abs(360-angle)+100)-4.6;   
            if(gsp &lt; 0.5)
            {
                gsp = 0;
                grounded = false;
                angle = 0;
            }
        }
    }
    */
    
    //FIXES DIRECTION
    gsp = sqrt(power(hsp,2)+power(vsp,2));
    if(rightLast)
    {
        hsp = cos(degtorad(angle))*gsp;
        vsp = -sin(degtorad(angle))*gsp;
    }
    else if(leftLast)
    {
        hsp = -cos(degtorad(angle))*gsp;
        vsp = sin(degtorad(angle))*gsp;
    }
}

if(jump &amp;&amp; grounded) &amp;&amp; place_meeting(x,y+1,obj_stable_ground)
{
    if(angle &lt;= 30 || angle &gt;= 330)
    {
        vsp -= jumpSpeed;
        grounded = false;
        //angle = 0;
    }
    else if(angle &gt;= 30 &amp;&amp; angle &lt;= 90)
    {
        vsp -= jumpSpeed/2;
        hsp -= jumpSpeed/2;
        grounded = false;
        //angle = 0;
    }
    else if(angle &gt;= 270 &amp;&amp; angle &lt;= 330)
    {
        vsp -= jumpSpeed/2;
        hsp += jumpSpeed/2;
        grounded = false;
        //angle = 0;
    }
}

if(!grounded)
{
    if(right)
    {
        hsp += rightSpeed;
        rightLast = true;
        leftLast = false;
    }
    else if(left)
    {
        hsp -= leftSpeed;
        rightLast = false;
        leftLast = true;
    }
}

//MAKES SURE YOU STAY NEXT TO WALL
for(i=0; !place_meeting(x+hsp,y+vsp,obj_stable_ground) &amp;&amp; grounded; i++)
{
    y+= (cos(degtorad(angle))*abs(x2-x1) + cos(degtorad(angle))*abs(y2-y1))/10;
    x+= (sin(degtorad(angle))*abs(y2-y1) + sin(degtorad(angle))*abs(x2-x1))/10;
    if(i &gt;= 30)
    {
        break;
    }
}

while(place_meeting(x+hsp,y+vsp,obj_stable_ground) &amp;&amp; grounded)
{
    y-= (cos(degtorad(angle))*abs(x2-x1) + cos(degtorad(angle))*abs(y2-y1))/10;
    x-= (sin(degtorad(angle))*abs(y2-y1) + sin(degtorad(angle))*abs(x2-x1))/10;
}

//CHECKING HORIZONTAL COLLISIONs IN AIR
if(place_meeting(x+hsp,y,obj_stable_ground) &amp;&amp; !grounded)
{
    while(!place_meeting(x+sign(hsp),y,obj_stable_ground))
    {
        x+= sign(hsp);
    }
    hsp = 0;
}
x+= hsp;

//CHECKING VERTICAL COLLISION IN AIR
if(place_meeting(x,y+vsp,obj_stable_ground) &amp;&amp; !grounded)
{
    while(!place_meeting(x,y+sign(vsp),obj_stable_ground))
    {
        y+= sign(vsp);
    }
    vsp = 0;
    if(place_meeting(x,y+1,obj_stable_ground))
    {
        grounded = true;
    }
}
y+=vsp;

//LOOPS ANGLE BY 360 DEGREES. 

if(angle &gt; 360)
{
    angle -= 360;
}
if(angle &lt; 0)
{
    angle+= 360;
}

lpositionx = x
positionx = (lpositionx-fpositionx);

//(TEMPORARY) CHECKING TO SEE IF YOU GET STUCK IN THE GROUND
if(place_meeting(x,y,obj_stable_ground))
{
    show_debug_message("AYY");
}
show_debug_message(grounded);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///TEST


/*
if(grounded)
{
    for(yy = 0; !position_meeting((x+cos(degtorad(image_angle))*10) + sin(degtorad(image_angle))*yy,(y-sin(degtorad(image_angle))*10)+cos(degtorad(image_angle))*yy,obj_stable_ground); yy++)
         {
             diff1X = yy;
             if(yy &gt;= 100)
             {
                 
             }
         }
    for(yy = 0; !position_meeting(x+(sin(degtorad(image_angle))*yy),y+(cos(degtorad(image_angle))*yy),obj_stable_ground); yy++)
     {
         diff1Y = yy;
         if(yy &gt;= 100)
         {
             break;
         }
     }
    
    x1 = (x+cos(degtorad(image_angle))*10) + sin(degtorad(image_angle))*diff1X;
    y1 = (y-sin(degtorad(image_angle))*10)+ cos(degtorad(image_angle))*diff1X;
    x2 = x+(sin(degtorad(image_angle))*diff1Y);
    y2 = y+(cos(degtorad(image_angle))*diff1Y);
    
    var dist = sqrt(power(x2-x1,2)+power(y2-y1,2));
    drawLine = true;
}
else
{
    drawLine = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

draw_set_colour(c_red)
draw_line(x,y,x+(hsp*5),y+(vsp*5));


if(drawLine == true)
{
   draw_set_colour(c_fuchsia);
   //Top right of slope to bottom left of slope
   draw_line(x1,y1,x2,y2);
   draw_set_colour(c_red);
   //Top right point of line to bottom right point of line
   draw_line(x+cos(degtorad(angle))*10,y-sin(degtorad(angle))*10,(x+cos(degtorad(angle))*10) + sin(degtorad(angle))*diff1X,(y-sin(degtorad(angle))*10)+cos(degtorad(angle))*diff1X);
   draw_set_colour(c_blue);
   //top left point of line to bottom left point of line. 
   draw_line(x,y,x+(sin(degtorad(angle))*diff1Y),y+(cos(degtorad(angle))*diff1Y));
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
