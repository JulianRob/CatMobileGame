<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_trunning</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_player</parentName>
  <maskName>spr_trunning</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_xscale = 0.3; //X Scale Size of Cat
image_yscale = 0.3; //Y Scale Size of Cat
image_speed = 0.5;  //Animation SPeed

hsp = 0; //Horizontal Speed
vsp = 0; //Vertical Speed
gsp = 0; //Ground Speed
hspl = 4.5; //Horizontal Speed Limit
vspl = 10; //Vertical Speed Limit 

grav = 0.5; //Gravity; 

grounded = false; //On the Ground

fric = 0.1; //Friction; 0.2

jumpSpeed = 9; //Speed Added When Pressing Jump Button (W)
rightSpeed = 0.5; //Speed Added When Holding Right Button (D)
leftSpeed = 0.5; //Speed Added When Holding Left Button (A)

angle = 0; //Angle of the Cat Relative to Ground.
angle2 = 0; //Actual Angle of Ground
angleJump = true; //Checks if Jumping After Landing
angleTime = true; //Landing Within Number of Frames

drawLine = false; //Draws Line from Player to Ground

x1 = 0; //Distance BEtween Top LEft Line and Top Right Line
y1 = 0; //Distance from Top Right to Bottom Right.
x2 = 0; //Point of Top Left Line
y2 = 0; //Distance from Top Left to Bottom Left
diff1X = 0; //Length of the Right Line.
diff1Y = 0;  //Length of the Left Line.

fpositionx = 0; //Initial X Position of Cat Before Movement
lpositionx = 0; //Final X Position of Cat After Movement
positionx = 0; //Difference in X Positions of Cat

fpositiony = 0; //Initial Y Position of Cat Before Movement
lpositiony = 0; //Final Y Position of Cat After Movement

kills = 0; //Number of Kills Player Gets

rightLast = false; //Right is the Last Direction Pressed
leftLast = false; //Left is the Last Direction Pressed

lastXPosition = 0; //Last x coordinate of player
lastYPosition = 0; //Last y coordinate of player 

saveAngle = 0; //Saves angle before lines drawn

faceLeft = false; //Set true by pressing left key last
faceRight = false; //Set true by pressing right key last

test = 0; //Testing Variables
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>angleTime = false;
alarm[0] = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//INITIAL POSITION OF CAT
fpositionx = x;
fpositiony = y;

//BUTTONS
right = keyboard_check(ord("D"));
left = keyboard_check(ord("A"));
jump = keyboard_check(ord("W"));

////////////////////////////////////////////////////PHYSICS PROPERTIES
//GRAVITY
if(!grounded)
{
    vsp += grav;
}

//HORIZONTAL AND VERTICAL FRICTION
if (hsp &gt; 0) {hsp -= fric;}
if (hsp &lt; 0) {hsp += fric;}
if (abs(hsp) &lt; fric) {hsp = 0;}

if(grounded)
{
    if (vsp &gt; 0) {vsp -=fric;}
    if (vsp &lt; 0) {vsp += fric;}
    if (abs(vsp) &lt; fric) {vsp = 0;}
}

//SPEED LIMITS
if(hsp &gt; hspl) {hsp = hspl;}
if(hsp &lt; -hspl) {hsp = -hspl;}
if(vsp &gt; vspl) {vsp = vspl;}
if(vsp &lt; -vspl) {vsp = -vspl;}

//DRAWS LINE FROM PLAYER TO GROUND
if(grounded)
{
    saveAngle = angle;
    //RIGHT LINE
    for(yy = 0; !position_meeting((x+cos(degtorad(angle))*5) + sin(degtorad(angle))*yy,(y-sin(degtorad(angle))*5)+cos(degtorad(angle))*yy,obj_stable_ground); yy++)
         {
             diff1X = yy; //Length of the right line.
             if(yy &gt;= 90)
             {
                 break;
             }
         }
    //LEFT LINE
    for(yy = 0; !position_meeting(x+(sin(degtorad(angle))*yy),y+(cos(degtorad(angle))*yy),obj_stable_ground); yy++)
     {
         diff1Y = yy; //Length of the left line. 
         if(yy &gt;= 90)
         {
             break;
         }
     }
     
     if(diff1X &gt;= 90 || diff1Y &gt;= 90)
     {
        angle = saveAngle;
        grounded = false;
     }
     
     if(grounded)
     {
        //Point of bottom right line. 
        x1 = (x+cos(degtorad(angle))*5) + sin(degtorad(angle))*diff1X; //Distance between top left line and top right line. 
        y1 = (y-sin(degtorad(angle))*5)+ cos(degtorad(angle))*diff1X; //Distance from top right to bottom right. 
        
        //Point of bottom left line. 
        x2 = x+(sin(degtorad(angle))*diff1Y); //Point of top left line. 
        y2 = y+(cos(degtorad(angle))*diff1Y); //Distance from top left to bottom left. 
        
        //Distance of slope
        var dist = sqrt(power(x2-x1,2)+power(y2-y1,2));
        
        //The distance of the slope is always costant. The difference in the lengths
        //of the lines will be 0 when angle is equal to the angle of the slope. 
        
        if(radtodeg(arctan2(diff1Y-diff1X,dist)) != 0)
        {
            angle += radtodeg(arctan2(diff1Y-diff1X,dist))/6;
            if(angleJump == true)
            {
                angle2 = radtodeg(arctan2(diff1Y-diff1X,dist))
                angleJump = false;
                angleTime = true;
                alarm[0] = 6;
            }
        }
        
        drawLine = true;
    }
}
else
{
    drawLine = false;
}

//LOOPS ANGLE BY 360 DEGREES. 

if(angle &gt; 360)
{
    angle -= 360;
}
if(angle &lt; 0)
{
    angle += 360;
}

if(angle2 &gt; 360)
{
    angle2 -= 360;
}
if(angle2 &lt; 0)
{
    angle2 += 360;
}

////////////////////////////////////////////////////PHYSICS PROPERTIES

//BUTTON PROPERTIES
if(grounded)
{
    ////CHANGES DIRECTION OF PLAYER BASED ON ANGLE
    if(right) 
    {          
        //ADDS SPEED TO DIRECTION
         hsp += cos(degtorad(angle))*rightSpeed; 
         vsp -= sin(degtorad(angle))*rightSpeed; 
         
         if(gsp &lt;= 1)
         {
             rightLast = true;
             leftLast = false;
         }
    }
    else if(left)
    {
        
        //ADDS SPEED TO DIRECTION
        hsp += -cos(degtorad(angle))*rightSpeed; 
        vsp +=  sin(degtorad(angle))*rightSpeed; 
        
        if(gsp &lt;= 1)
        {
           rightLast = false;
           leftLast = true;
        }
    }
    
    /*
    //DECREASE SPEED ON SLOPE
    gsp = sqrt(power(hsp,2)+power(vsp,2));
    if(angle &gt; 0 &amp;&amp; angle &lt;= 180 &amp;&amp; (!left || (left &amp;&amp; right)))
    {
        if(ln(angle+100)-4.6 &gt; gsp)
        {
            gsp = 0;
            grounded = false;
            angle = 0;
        }
        else
        {
            gsp -= ln(angle+100)-4.6;   
            if(gsp &lt; 0.5)
            {
                gsp = 0;
                grounded = false;
                angle = 0;
            }
        }
    }
    
    if(angle &gt; 180 &amp;&amp; angle &lt;= 360 &amp;&amp; !right)
    {
        if(ln(abs(360-angle)+100)-4.6 &gt; gsp)
        {
            gsp = 0;
            grounded = false;
            angle = 0;
        }
        else
        {
            gsp -= ln(abs(360-angle)+100)-4.6;   
            if(gsp &lt; 0.5)
            {
                gsp = 0;
                grounded = false;
                angle = 0;
            }
        }
    }
    */
    
    //FIXES DIRECTION
    gsp = sqrt(power(hsp,2)+power(vsp,2));
    if(rightLast)
    {
        hsp = cos(degtorad(angle))*gsp;
        vsp = -sin(degtorad(angle))*gsp;
    }
    else if(leftLast)
    {
        hsp = -cos(degtorad(angle))*gsp;
        vsp = sin(degtorad(angle))*gsp;
    }
}

if(jump &amp;&amp; grounded) &amp;&amp; place_meeting(x,y+1,obj_stable_ground)
{
    if(angleTime == true)
    {
        if(angle2 &lt;= 30 || angle2 &gt;= 330)
        {
            vsp -= jumpSpeed;
            grounded = false;
        }
        else if(angle2 &gt;= 30 &amp;&amp; angle2 &lt;= 90)
        {
            vsp -= jumpSpeed/2;
            hsp -= jumpSpeed/2;
            grounded = false;
        }
        else if(angle2 &gt;= 270 &amp;&amp; angle2 &lt;= 330)
        {
            vsp -= jumpSpeed/2;
            hsp += jumpSpeed/2;
            grounded = false;
        }
    }
    else
    {
        if(angle &lt;= 30 || angle &gt;= 330)
        {
            vsp -= jumpSpeed;
            grounded = false;
        }
        else if(angle &gt;= 30 &amp;&amp; angle &lt;= 90)
        {
            vsp -= jumpSpeed/2;
            hsp -= jumpSpeed/2;
            grounded = false;
        }
        else if(angle &gt;= 270 &amp;&amp; angle &lt;= 330)
        {
            vsp -= jumpSpeed/2;
            hsp += jumpSpeed/2;
            grounded = false;
        }
    }
    angleTime = false;
    angleJump = true;
}

if(!grounded)
{
    if(right)
    {
        hsp += rightSpeed;
        rightLast = true;
        leftLast = false;
    }
    else if(left)
    {
        hsp -= leftSpeed;
        rightLast = false;
        leftLast = true;
    }
}

if (!collision_circle( x, y, 20, obj_stable_ground, true, true ))
{
    grounded = false;
}

lastXPosition = x;
lastYPosition = y;

//MAKES SURE YOU STAY NEXT TO WALL
for(i=0; !place_meeting(x+hsp,y+vsp,obj_stable_ground) &amp;&amp; grounded; i++)
{
    y+= (cos(degtorad(angle))*abs(x2-x1) + cos(degtorad(angle))*abs(y2-y1))/10;
    x+= (sin(degtorad(angle))*abs(y2-y1) + sin(degtorad(angle))*abs(x2-x1))/10;
    if(i &gt;= 30)
    {
        break;
    }
}

for(i = 0; place_meeting(x+hsp,y+vsp,obj_stable_ground) &amp;&amp; grounded; i++)
{
    y-= (cos(degtorad(angle))*abs(x2-x1) + cos(degtorad(angle))*abs(y2-y1))/10;
    x-= (sin(degtorad(angle))*abs(y2-y1) + sin(degtorad(angle))*abs(x2-x1))/10;
    if(i &gt; 30)
    {
        x = lastXPosition;
        y = lastYPosition;
        hsp = 0;
        vsp = 0;
        gsp = 0;
        break;
    }
}

//CHECKING HORIZONTAL COLLISIONs IN AIR
if(place_meeting(x+hsp,y,obj_stable_ground) &amp;&amp; !grounded)
{
    while(!place_meeting(x+sign(hsp),y,obj_stable_ground))
    {
        x+= sign(hsp);
    }
    hsp = 0;
}
x+= hsp;

//CHECKING VERTICAL COLLISION IN AIR
if(place_meeting(x,y+vsp,obj_stable_ground) &amp;&amp; !grounded)
{
    while(!place_meeting(x,y+sign(vsp),obj_stable_ground))
    {
        y+= sign(vsp);
    }
    vsp = 0;
    if(place_meeting(x,y+1,obj_stable_ground))
    {
        grounded = true;
        angle = 0;
    }
}
y+=vsp;

//FIXES GETTING STUCK ON EDGES Problem: Fidgets against vertical ground
/*
if(fpositionx == x &amp;&amp; fpositiony == y &amp;&amp; !grounded &amp;&amp; position_meeting(x+5,y,obj_stable_ground))
{
    if(!place_meeting(x-5,y,obj_stable_ground))
    {
        x-=5;
    }
}
else if(fpositionx == x &amp;&amp; fpositiony == y &amp;&amp; !grounded &amp;&amp; position_meeting(x-5,y,obj_stable_ground))
{
    if(!place_meeting(x+5,y,obj_stable_ground))
    {
        x+=5;
    }
}
*/

/*
if(fpositionx == x &amp;&amp; fpositiony == y &amp;&amp; right == true &amp;&amp; !grounded)
{
    if(!place_meeting(x-5,y,obj_stable_ground))
    {
        x-=5;
    }
}
else if(fpositionx == x &amp;&amp; fpositiony == y &amp;&amp; left == true &amp;&amp; !grounded)
{
    if(!place_meeting(x+5,y,obj_stable_ground))
    {
        x+=5;
    }
}
*/



lpositionx = x;

positionx = (lpositionx-fpositionx);

//SETS CAT'S ANIMATION SPEED

gsp = sqrt(power(hsp,2)+power(vsp,2));
image_speed = gsp*(.5/5);

//(TEMPORARY) CHECKING TO SEE IF YOU GET STUCK IN THE GROUND
if(place_meeting(x,y,obj_stable_ground))
{
    show_debug_message("AYY");
}

show_debug_message(angle2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(right)
{
    draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, angle, image_blend, image_alpha); 
    faceRight = true;
    faceLeft = false;
} else if (left)
{
    draw_sprite_ext(sprite_index, image_index, x, y, -image_xscale, image_yscale, angle, image_blend, image_alpha); 
    faceRight = false;
    faceLeft = true;
}
else
{
    if(faceRight)
    {
        draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, angle, image_blend, image_alpha);    
    }
    else if (faceLeft)
    {
        draw_sprite_ext(sprite_index, image_index, x, y, -image_xscale, image_yscale, angle, image_blend, image_alpha); 
    }
    else
    {
        draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, angle, image_blend, image_alpha);    
    }
}


draw_set_colour(c_red)
draw_line(x,y,x+(hsp*5),y+(vsp*5));


if(drawLine == true)
{
   draw_set_colour(c_fuchsia);
   //Top right of slope to bottom left of slope
   draw_line(x1,y1,x2,y2);
   draw_set_colour(c_red);
   //Top right point of line to bottom right point of line
   draw_line(x+cos(degtorad(angle))*5,y-sin(degtorad(angle))*5,(x+cos(degtorad(angle))*5) + sin(degtorad(angle))*diff1X,(y-sin(degtorad(angle))*5)+cos(degtorad(angle))*diff1X);
   draw_set_colour(c_blue);
   //top left point of line to bottom left point of line. 
   draw_line(x,y,x+(sin(degtorad(angle))*diff1Y),y+(cos(degtorad(angle))*diff1Y));
}

//draw_set_colour(c_blue);
//draw_circle(x, y, 20, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
