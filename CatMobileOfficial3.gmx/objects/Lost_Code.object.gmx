<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///////////////////////////////////////////////////////////////////USED TO MOVE AN OBJECT IN A DIRECTION PRECISELY
/*
if(keyboard_check_pressed(vk_up))
{
    modify-=1;
}

if(keyboard_check_pressed(vk_down))
{
    modify+=1;
}

if(keyboard_check_pressed(vk_left))
{
    modify2-=1;
}

if(keyboard_check_pressed(vk_right))
{
    modify2+=1;
}
*/
///////////////////////////////////////////////////////////////////USED TO MOVE AN OBJECT IN A DIRECTION PRECISELY

///////////////////////////////////////////////////////////ROTATES PLAYER WHEN IN AIR
/*
if(!grounded)
{   
  // grav = 1;
    if(image_angle &gt;= 2)
    {  
      image_angle -= 1;  
    }
    else if(image_angle &lt;= -2)
    {
        image_angle += 1;
    }
    else
    {
        image_angle = 0;
    }
}
*/
///////////////////////////////////////////////////////////ROTATES PLAYER WHEN IN AIR

///////////////////////////////////////////////////////////////////////////////////////////CODE FOR MOVEMENT
/* 
hsp = 0; //Reset Horizontal Speed

if(up) //Jump button
{
   if (grounded)
    {
     state = 2;
     if(alarm[1] == -1)
     {
        alarm[1] = 4;
     }
    }
    obj_up.image_alpha = .5;
}
else
{
    obj_up.image_alpha = 1;
}

if(!grounded)
{
    vsp+= 1;
    if(right)
    {
        hsp+=10; //runRight
    }
    if(left)
    {
        hsp+=-10; //runLeft
    }
    
    if(place_meeting(x+hsp,y,obj_gr))
    {
         while(!place_meeting(x+hsp,y,obj_gr))
            {
                x+=sign(hsp);
                speedx += sign(hsp);
            }
            hsp = 0;
    }
    else
    {
        x+=hsp;
        speedx +=hsp;
    }
    
    if(place_meeting(x,y+vsp,obj_gr))
    {
       while(!place_meeting(x,y+vsp,obj_gr))
            {
                y+=sign(vsp);
            }
        vsp = 0;
        grounded = true;
        show_debug_message("Test");
    }
    else
    {
        y+=vsp;
    }
}
else
{
    vsp = 0;
}

*/

/*
//Angled Movement
if(grounded)
{
    var count = 0;
    var fAngle = image_angle; //first angle
        for(yy = 0; !position_meeting((x+cos(degtorad(image_angle))*10) + sin(degtorad(image_angle))*yy,(y-sin(degtorad(image_angle))*10)+cos(degtorad(image_angle))*yy,obj_stable_ground); yy++)
            {
                diff1X = yy;
                if(yy &gt;= 100)
                {
                    count+=1;
                    if(right)
                    {
                        image_angle+=90;
                        yy=0;
                    }
                    if(left)
                    {
                        image_angle-=90;
                        yy=0;
                    }
                    if(count&gt;=3)
                    {
                        grounded = false;
                        image_angle = fAngle;
                        break;
                    }
                }
            }
            
    if(grounded)
    {
        for(yy = 0; !position_meeting(x+(sin(degtorad(image_angle))*yy),y+(cos(degtorad(image_angle))*yy),obj_stable_ground); yy++)
        {
            diff1Y = yy;
            if(yy &gt;= 100)
            {
                break;
            }
        }
     
        x1 = (x+cos(degtorad(image_angle))*10) + sin(degtorad(image_angle))*diff1X;
        y1 = (y-sin(degtorad(image_angle))*10)+ cos(degtorad(image_angle))*diff1X;
        x2 = x+(sin(degtorad(image_angle))*diff1Y);
        y2 = y+(cos(degtorad(image_angle))*diff1Y);
        
        runRight = x1-x2;
        runLeft = x2-x1;
    
        gravY = (x1-x2);
        gravX = (y2-y1);
        
        line1 = true;
        var dist = sqrt(power(x2-x1,2)+power(y2-y1,2));
    
        if(radtodeg(arctan2(diff1Y-diff1X,dist)) != 0)
        {
            image_angle += radtodeg(arctan2(diff1Y-diff1X,dist))/3;
        }
    }
}
else
{
    line1 = false;
}

if(grounded)
{
    if(right)
    {
        hsp += sign(runRight)*10;
        vsp += sign(y1-y2)*10;
    }
    
    if(left)
    {
        hsp += sign(runLeft)*10+gravX; 
        vsp += sign(y2-y1)*10+gravY;   
    }
    
    if (place_meeting(x+hsp,y+vsp,obj_gr))
    {   
        while(place_meeting(x+hsp,y,obj_gr) || place_meeting(x,y+vsp,obj_gr))
        {
            y-=gravY;
            x-=gravX;
            speedx-= gravX;
        }
        
        x+=hsp;
        speedx +=hsp;
         
        /////////////////////////////NOT INCLUDED
        if(place_meeting(x+hsp,y,obj_gr))
        {
             while(!place_meeting(x+hsp,y,obj_gr))
                {
                    x+=sign(hsp);
                    speedx += sign(hsp);
                }
                hsp = 0;
        }
        else
        {
            x+=hsp;
            speedx +=hsp;
        }
        //////////////////////////////////////NOT INCLUDED
        
        if(place_meeting(x,y+vsp,obj_gr))
        {
           while(place_meeting(x+hsp,y,obj_gr) || place_meeting(x,y+vsp,obj_gr))
            {
                y-=gravY;
                x-=gravX;
                speedx-= gravX;
            }
            y+=vsp;
        }
        else
        {
            y+=vsp;
        }
    }
    else
    {
        x += hsp;
        y += vsp;
        speedx += hsp;
    }
    
    if(place_meeting(x+gravX,y,obj_gr))
    {
        while(!place_meeting(x+gravX,y,obj_gr))
        {
            x+=sign(gravX);
            speedx += sign(gravX);
        }
        gravX = 0;
    }
    else
    {
        x+=gravX;
        speedx += gravX;
    }
    
    if(place_meeting(x,y+gravY,obj_gr))
    {
        while(!place_meeting(x,y+gravY,obj_gr))
        {
            y+=sign(gravY);
        }
        gravY = 0;
    }
    else
    {
        y+=gravY;
    }
}
*/ ///////////////////////////////////CODE FOR MOVEMENT
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
